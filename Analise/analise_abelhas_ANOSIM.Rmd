---
title: "Composi√ß√£o/diversidade de comunidades de abelhas em fun√ß√£o da estrutura da paisagem"
subtitle: "Estrutura da Paisagem (propor√ß√£o de habitat natural x heterogeneidade) e Composi√ß√£o de Esp√©cies - VERS√ÉO ANOSIM"
author: "Cinthia Soares Novaes"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    theme: flatly
    highlight: tango
    code_folding: show
    df_print: paged
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 7,
  fig.align = 'center'
)
```

# Introdu√ß√£o {.tabset}

## Contexto
*Pergunta: Como a composi√ß√£o e a diversidade de abelhas respondem √† estrutura da paisagem, considerando a propor√ß√£o de habitat natural e a heterogeneidade de usos e coberturas do solo?*

**H1:** A diversidade e a composi√ß√£o de abelhas est√£o mais fortemente associadas √† propor√ß√£o de habitat natural, de modo que √°reas com maior cobertura natural apresentam maior diversidade de esp√©cies.

**H2:** Mosaicos de diferentes classes de uso e cobertura do solo oferecem recursos complementares que sustentam maior diversidade e mant√™m comunidades distintas, tornando a heterogeneidade da paisagem um preditor mais importante.

**H0:** N√£o h√° associa√ß√£o significativa entre a propor√ß√£o de habitat natural e a heterogeneidade da paisagem e os padr√µes de diversidade e composi√ß√£o de abelhas neste estudo. As diferen√ßas observadas podem ser atribu√≠das ao acaso ou a fatores n√£o identificados na presente abordagem.


**Delineamento amostral:**
- **6 locais** com diferentes contextos (3 bordas urbanas + 3 zonas rurais)
- **Locais urbanos: TM, IF e MARM**
- **Locais rurais: CUR, SG e MV** 
- **9 pontos** por local (3 transectos √ó 3 pontos)
- **Total: 54 pontos amostrais**

## Objetivos

Os principais objetivos desta an√°lise s√£o:

1. **Diversidade Alfa**: Avaliar como a propor√ß√£o de habitat natural e a heterogeneidade da paisagem afetam a riqueza de esp√©cies (usando GLMM para controlar pseudorreplica√ß√£o)
2. **Composi√ß√£o Beta**: Testar se √°reas de borda urbana diferem de zonas rurais em termos de composi√ß√£o de esp√©cies
3. **An√°lises Multivariadas**: Identificar padr√µes espaciais na estrutura das comunidades

## M√©todos Estat√≠sticos

- **GLMM (Modelo Misto)**: Riqueza por ponto (n=54) com Local como efeito aleat√≥rio
- **NMDS**: Ordena√ß√£o da composi√ß√£o de esp√©cies
- **ANOSIM**: Teste de diferen√ßas entre grupos (contextos, locais e categorias de habitat)
- **ANOSIM Bloqueado**: Controla pseudorreplica√ß√£o atrav√©s de blocos (Local)
- **An√°lise Multiescala**: Compara√ß√£o entre pontos (n=54) e transectos (n=18)

---

# Configura√ß√£o Inicial

## Carregar Pacotes
```{r pacotes}
library(tidyverse)
library(readxl)
library(vegan)
library(lme4)
library(MuMIn)
library(ggplot2)
library(viridis)
library(gridExtra)
library(car)
```

## Importar e Limpar Dados
```{r importar-dados}
dados <- read_excel("../dados/Cap2.xlsx", sheet = "Doc_Cinthia")

dados <- dados %>%
  filter(
    Especie != "Vespa",
    Especie != "NA",
    !is.na(Especie),
    Especie != "Crabronidae sp.",
    Especie != "Xylocopa grisescens"
  ) %>%
  mutate(
    Especie = str_trim(Especie),
    total_paisagem = Area_Natural + Area_Urbana + Pastagem + Mosaico_Usos +
      Areas_nao_veg. + Mineracao + Lagos + Lavouras_Temp.,
    contexto = case_when(
      Local %in% c("TM_", "IF_", "MARM_") ~ "Borda_Urbana",
      Local %in% c("SG_", "MV_", "CUR_") ~ "Zona_Rural",
      TRUE ~ NA_character_
    ),
    ID_ponto = paste(Local, Ponto, sep = "_")
  )

cat("üìä DADOS CARREGADOS:\n")
cat("  - Total de registros:", nrow(dados), "\n")
cat("  - N√∫mero de esp√©cies:", n_distinct(dados$Especie), "\n")
cat("  - Locais amostrados:", n_distinct(dados$Local), "\n")
cat("  - Pontos √∫nicos:", n_distinct(dados$ID_ponto), "\n")
```

---

# Diversidade Alfa (GLMM - 54 pontos)

## Calcular Riqueza por Ponto
```{r riqueza-pontos}
riqueza_por_ponto <- dados %>%
  group_by(ID_ponto) %>%
  summarise(
    Local = first(Local),
    contexto = first(contexto),
    prop_hab_natural = first(Area_Natural) / first(total_paisagem),
    heterogeneidade = vegan::diversity(
      c(first(Area_Urbana), first(Pastagem), first(Mosaico_Usos),
        first(Areas_nao_veg.), first(Mineracao), first(Lagos), 
        first(Lavouras_Temp.)),
      index = "shannon"
    ),
    riqueza = n_distinct(Especie),
    abundancia = n(),
    .groups = "drop"
  )

cat("üìä Resumo da riqueza por ponto:\n")
print(summary(riqueza_por_ponto))

cat("\nüìà Estat√≠sticas descritivas:\n")
cat("  - Riqueza m√©dia:", round(mean(riqueza_por_ponto$riqueza), 2), "¬±", 
    round(sd(riqueza_por_ponto$riqueza), 2), "\n")
cat("  - Riqueza m√≠nima:", min(riqueza_por_ponto$riqueza), "\n")
cat("  - Riqueza m√°xima:", max(riqueza_por_ponto$riqueza), "\n")
```

## Modelos Lineares Generalizados Mistos (GLMM)

### Sele√ß√£o de Modelos
```{r glmm-selecao}
cat("\n=== AJUSTANDO GLMMs ===\n")
cat("Local √© inclu√≠do como efeito aleat√≥rio para controlar pseudorreplica√ß√£o\n\n")

m1 <- glmer(riqueza ~ prop_hab_natural + (1|Local), 
            data = riqueza_por_ponto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m2 <- glmer(riqueza ~ heterogeneidade + (1|Local), 
            data = riqueza_por_ponto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m3 <- glmer(riqueza ~ prop_hab_natural + heterogeneidade + (1|Local), 
            data = riqueza_por_ponto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m4 <- glmer(riqueza ~ prop_hab_natural * heterogeneidade + (1|Local), 
            data = riqueza_por_ponto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m5 <- glmer(riqueza ~ prop_hab_natural + heterogeneidade + contexto + (1|Local), 
            data = riqueza_por_ponto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

tabela_modelos <- model.sel(m1, m2, m3, m4, m5)
print(tabela_modelos)
```

### Diagn√≥stico e Corre√ß√£o de Multicolinearidade
```{r diagnostico-multicolinearidade}
cat("\n\n")
cat("===============================================================\n")
cat("       DIAGN√ìSTICO E CORRE√á√ÉO DE MULTICOLINEARIDADE           \n")
cat("===============================================================\n\n")

correlacao <- cor(riqueza_por_ponto$prop_hab_natural, 
                  riqueza_por_ponto$heterogeneidade)
cat("üìä Correla√ß√£o entre habitat natural e heterogeneidade:", round(correlacao, 3), "\n\n")

if(abs(correlacao) > 0.7) {
  cat("‚ö†Ô∏è Correla√ß√£o alta (|r| > 0.7) - Multicolinearidade esperada\n")
} else {
  cat("‚úì Correla√ß√£o moderada - VIF alto pode ser devido √† intera√ß√£o\n")
}

p_corr <- ggplot(riqueza_por_ponto, 
                 aes(x = prop_hab_natural, y = heterogeneidade, color = contexto)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linewidth = 1) +
  scale_color_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60")) +
  annotate("text", x = Inf, y = Inf, 
           label = paste("r =", round(correlacao, 3)), 
           hjust = 1.1, vjust = 1.5, size = 5, fontface = "bold") +
  theme_bw(base_size = 14) +
  labs(x = "Propor√ß√£o de Habitat Natural",
       y = "Heterogeneidade (Shannon)",
       title = "Correla√ß√£o entre Preditores",
       color = "Contexto")
print(p_corr)

cat("\n=== CORRIGINDO MULTICOLINEARIDADE ===\n")
cat("Centrando vari√°veis (subtraindo a m√©dia)...\n\n")

riqueza_por_ponto <- riqueza_por_ponto %>%
  mutate(
    prop_hab_natural_c = scale(prop_hab_natural, center = TRUE, scale = FALSE)[,1],
    heterogeneidade_c = scale(heterogeneidade, center = TRUE, scale = FALSE)[,1]
  )

cat("Refazendo modelos com vari√°veis centradas...\n\n")

m1_c <- glmer(riqueza ~ prop_hab_natural_c + (1|Local), 
              data = riqueza_por_ponto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

m2_c <- glmer(riqueza ~ heterogeneidade_c + (1|Local), 
              data = riqueza_por_ponto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

m3_c <- glmer(riqueza ~ prop_hab_natural_c + heterogeneidade_c + (1|Local), 
              data = riqueza_por_ponto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

m4_c <- glmer(riqueza ~ prop_hab_natural_c * heterogeneidade_c + (1|Local), 
              data = riqueza_por_ponto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

m5_c <- glmer(riqueza ~ prop_hab_natural_c + heterogeneidade_c + contexto + (1|Local), 
              data = riqueza_por_ponto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

tabela_modelos_centrados <- model.sel(m1_c, m2_c, m3_c, m4_c, m5_c)
cat("=== SELE√á√ÉO DE MODELOS (Vari√°veis Centradas) ===\n")
print(tabela_modelos_centrados)

melhor_modelo_centrado <- get.models(tabela_modelos_centrados, subset = 1)[[1]]

cat("\nüìä MELHOR MODELO CENTRADO:\n")
cat("AICc:", round(AICc(melhor_modelo_centrado), 2), "\n\n")

if(length(fixef(melhor_modelo_centrado)) > 2) {
  cat("üîç VIF ap√≥s centrar:\n")
  vif_centrado <- vif(melhor_modelo_centrado)
  print(vif_centrado)
  
  cat("\nüìä Compara√ß√£o do VIF:\n")
  cat("Antes de centrar: 10.9 / 22.4 / 31.1\n")
  cat("Depois de centrar:", paste(round(vif_centrado, 1), collapse = " / "), "\n\n")
  
  if(max(vif_centrado) < 10) {
    cat("‚úÖ VIF melhorou significativamente! Multicolinearidade controlada.\n")
  } else {
    cat("‚ö†Ô∏è VIF ainda alto. Considere usar apenas modelos univariados (m1_c ou m2_c).\n")
  }
}

cat("\nüìä COEFICIENTES DO MELHOR MODELO (Centrado):\n")
print(summary(melhor_modelo_centrado)$coefficients)

cat("\n\n=== COMPARA√á√ÉO: Modelos Univariados vs Complexos ===\n")
comparacao_simples <- model.sel(m1_c, m2_c, m3_c, m4_c)
print(comparacao_simples)

cat("\nüí° INTERPRETA√á√ÉO:\n")
idx_m1 <- which(rownames(comparacao_simples) == "m1_c")
if(length(idx_m1) > 0) {
  delta_m1 <- comparacao_simples$delta[idx_m1]
  
  if(delta_m1 < 2) {
    cat("ŒîAICc < 2 para m1 (s√≥ habitat natural) ‚Üí Modelo univariado √© suficiente!\n")
    cat("Recomenda√ß√£o: Use m1_c como modelo final (mais parcimonioso)\n")
  } else {
    cat("ŒîAICc ‚â• 2 para m1 ‚Üí Modelo mais complexo √© justificado\n")
  }
}
```

### Melhor Modelo
```{r glmm-melhor}
melhor_modelo <- melhor_modelo_centrado

cat("\nüìä MELHOR MODELO (menor AICc):\n")
cat("AICc:", round(AICc(melhor_modelo), 2), "\n")
cat("ŒîAICc:", round(tabela_modelos_centrados$delta[1], 2), "\n\n")

cat("Efeitos fixos:\n")
print(summary(melhor_modelo)$coefficients)

cat("\n\nVari√¢ncia do efeito aleat√≥rio (Local):\n")
print(VarCorr(melhor_modelo))

deviance_residual <- sum(residuals(melhor_modelo, type = "deviance")^2)
df_residual <- df.residual(melhor_modelo)
dispersion <- deviance_residual / df_residual

cat("\nüîç Teste de Overdispersion:", round(dispersion, 3), "\n")
if(dispersion > 1.5) {
  cat("‚ö†Ô∏è Overdispersion detectada (>1.5). Considere usar fam√≠lia Negative Binomial.\n")
} else {
  cat("‚úì Sem problemas de overdispersion.\n")
}

if(length(fixef(melhor_modelo)) > 2) {
  cat("\nüîç VIF (Colinearidade dos preditores - ap√≥s centrar):\n")
  cat("VIF > 3 indica colinearidade problem√°tica\n\n")
  print(vif(melhor_modelo))
}
```

**Interpreta√ß√£o:** O modelo misto (GLMM) usa os 54 pontos mas controla a n√£o-independ√™ncia dos pontos dentro de cada local atrav√©s do efeito aleat√≥rio `(1|Local)`. Vari√°veis foram centradas para reduzir multicolinearidade causada pela intera√ß√£o.

---

# An√°lises Multivariadas (54 pontos)

## Preparar Matrizes
```{r preparar-matrizes}
matriz_comunidade_pontos <- dados %>%
  group_by(ID_ponto, Especie) %>%
  summarise(abundancia = n(), .groups = "drop") %>%
  pivot_wider(names_from = Especie, values_from = abundancia, values_fill = 0) %>%
  column_to_rownames("ID_ponto")

cat("üìê Dimens√µes da matriz:", dim(matriz_comunidade_pontos), "\n")
cat("   (", nrow(matriz_comunidade_pontos), " pontos √ó ", 
    ncol(matriz_comunidade_pontos), " esp√©cies)\n\n", sep = "")

variaveis_pontos <- dados %>%
  group_by(ID_ponto) %>%
  summarise(
    Local = first(Local),
    contexto = first(contexto),
    prop_hab_natural = first(Area_Natural) / first(total_paisagem),
    heterogeneidade = vegan::diversity(
      c(first(Area_Urbana), first(Pastagem), first(Mosaico_Usos),
        first(Areas_nao_veg.), first(Mineracao), first(Lagos), 
        first(Lavouras_Temp.)),
      index = "shannon"
    ),
    .groups = "drop"
  ) %>%
  column_to_rownames("ID_ponto")

cat("‚úì Alinhamento de matrizes:", 
    all(rownames(matriz_comunidade_pontos) == rownames(variaveis_pontos)), "\n")
```

## NMDS (Ordena√ß√£o)
```{r nmds}
cat("\n=== CALCULANDO NMDS ===\n")

set.seed(123)
nmds_pontos <- metaMDS(matriz_comunidade_pontos, 
                       distance = "bray", 
                       k = 2,
                       trymax = 100,
                       trace = FALSE)

cat("üìä Stress do NMDS (k=2):", round(nmds_pontos$stress, 4), "\n\n")
cat("Interpreta√ß√£o do Stress:\n")
cat("  < 0.05: Excelente\n")
cat("  0.05-0.10: √ìtimo\n")
cat("  0.10-0.20: Bom\n")
cat("  > 0.20: Regular/Ruim\n")

if(nmds_pontos$stress > 0.20) {
  cat("\n‚ö†Ô∏è Stress alto! Tentando k=3...\n")
  nmds_pontos <- metaMDS(matriz_comunidade_pontos, 
                         distance = "bray", 
                         k = 3,
                         trymax = 100,
                         trace = FALSE)
  cat("‚úì Novo stress (k=3):", round(nmds_pontos$stress, 4), "\n")
}
```

## ANOSIM - An√°lise Principal

### ANOSIM por Grupos Categ√≥ricos
```{r anosim-principal}
cat("\n\n=== ANOSIM: AN√ÅLISE DE SIMILARIDADE ===\n")
cat("ANOSIM testa se as diferen√ßas ENTRE grupos s√£o maiores que DENTRO dos grupos\n")
cat("R statistic varia de -1 a +1:\n")
cat("  R ~ 0: Grupos n√£o diferem\n")
cat("  R > 0.5: Grupos bem separados\n")
cat("  R = 1: Grupos completamente distintos\n\n")

dist_bray <- vegdist(matriz_comunidade_pontos, method = "bray")

anosim_contexto <- anosim(dist_bray, variaveis_pontos$contexto, permutations = 999)

anosim_local <- anosim(dist_bray, variaveis_pontos$Local, permutations = 999)

tercis <- quantile(variaveis_pontos$prop_hab_natural, probs = c(0.33, 0.67))
categoria_habitat <- cut(variaveis_pontos$prop_hab_natural,
                         breaks = c(-Inf, tercis[1], tercis[2], Inf),
                         labels = c("Baixo", "Medio", "Alto"))
anosim_habitat <- anosim(dist_bray, categoria_habitat, permutations = 999)

tercis_het <- quantile(variaveis_pontos$heterogeneidade, probs = c(0.33, 0.67))
categoria_heterog <- cut(variaveis_pontos$heterogeneidade,
                         breaks = c(-Inf, tercis_het[1], tercis_het[2], Inf),
                         labels = c("Baixo", "Medio", "Alto"))
anosim_heterog <- anosim(dist_bray, categoria_heterog, permutations = 999)

cat("--- ANOSIM: Borda Urbana vs Zona Rural ---\n")
print(summary(anosim_contexto))
cat("\n--- ANOSIM: Entre os 6 Locais ---\n")
print(summary(anosim_local))
cat("\n--- ANOSIM: Por Categoria de Habitat Natural ---\n")
print(summary(anosim_habitat))
cat("\n--- ANOSIM: Por Categoria de Heterogeneidade ---\n")
print(summary(anosim_heterog))
```

### ANOSIM Bloqueado (Controla Pseudorreplica√ß√£o)
```{r anosim-bloqueado}
cat("\n\n=== ANOSIM BLOQUEADO ===\n")
cat("Usa 'strata' para controlar a pseudorreplica√ß√£o dos pontos dentro de cada Local\n\n")

anosim_blocked_contexto <- anosim(dist_bray, 
                                  variaveis_pontos$contexto, 
                                  permutations = 999,
                                  strata = variaveis_pontos$Local)

cat("--- ANOSIM BLOQUEADO: Contexto (controlando Local) ---\n")
print(summary(anosim_blocked_contexto))
cat("\nüí° Esta an√°lise controla a pseudorreplica√ß√£o dos pontos dentro de cada local!\n")
```

**Interpreta√ß√£o:** O ANOSIM bloqueado √© an√°logo √† PERMANOVA bloqueada - ele controla o fato de que os 9 pontos dentro de cada local n√£o s√£o completamente independentes, usando permuta√ß√µes restritas dentro dos blocos (locais).

### ANOSIM Pairwise
```{r anosim-pairwise}
cat("\n--- ANOSIM Pairwise (Compara√ß√µes entre Locais) ---\n")

locais_unicos <- unique(variaveis_pontos$Local)
n_locais <- length(locais_unicos)

resultados_pairwise <- data.frame(
  Comparacao = character(),
  R_statistic = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

for(i in 1:(n_locais-1)) {
  for(j in (i+1):n_locais) {
    local_A <- locais_unicos[i]
    local_B <- locais_unicos[j]
    
    indices <- variaveis_pontos$Local %in% c(local_A, local_B)
    dist_sub <- as.dist(as.matrix(dist_bray)[indices, indices])
    grupos_sub <- variaveis_pontos$Local[indices]
    
    anosim_pair <- anosim(dist_sub, grupos_sub, permutations = 999)
    
    resultados_pairwise <- rbind(resultados_pairwise, 
                                 data.frame(
                                   Comparacao = paste(local_A, "vs", local_B),
                                   R_statistic = anosim_pair$statistic,
                                   p_value = anosim_pair$signif
                                 ))
  }
}

resultados_pairwise$p_adjusted <- p.adjust(resultados_pairwise$p_value, method = "bonferroni")
resultados_pairwise <- resultados_pairwise %>% arrange(desc(R_statistic))

print(resultados_pairwise)
```

## ENVFIT (Vetores Ambientais)
```{r envfit}
cat("\n\n=== ENVFIT: Vetores Ambientais ===\n")

envfit_resultado <- envfit(nmds_pontos, 
                           variaveis_pontos[, c("prop_hab_natural", "heterogeneidade")],
                           permutations = 999)
print(envfit_resultado)
```

---

# An√°lise Complementar com Transectos (n=18)
```{r analise-transectos}
cat("\n\n")
cat("===============================================================\n")
cat("   AN√ÅLISE USANDO TRANSECTOS COMO UNIDADES AMOSTRAIS (n=18)   \n")
cat("===============================================================\n\n")

cat("üìå ESTRUTURA DOS DADOS:\n")
cat("  - 6 locais (IF, TM, MARM, SG, MV, CUR)\n")
cat("  - 3 transectos por local (URB, TRAN, NAT)\n")
cat("  - 3 pontos por transecto\n")
cat("  - Total: 18 transectos (6 √ó 3)\n\n")

cat("=== PREPARANDO DADOS POR TRANSECTO ===\n\n")

dados_transecto <- dados %>%
  mutate(
    transecto = str_remove(Ponto, "[0-9]+"),
    ID_transecto = paste(Local, transecto, sep = "_")
  )

cat("Exemplo de IDs de transecto criados:\n")
print(head(unique(dados_transecto$ID_transecto), 10))

cat("\nTotal de transectos √∫nicos:", n_distinct(dados_transecto$ID_transecto), "\n")

riqueza_transecto <- dados_transecto %>%
  group_by(ID_transecto) %>%
  summarise(
    Local = first(Local),
    transecto = first(transecto),
    contexto = first(contexto),
    prop_hab_natural = mean(Area_Natural / total_paisagem, na.rm = TRUE),
    heterogeneidade = mean(vegan::diversity(
      c(Area_Urbana, Pastagem, Mosaico_Usos, Areas_nao_veg., 
        Mineracao, Lagos, Lavouras_Temp.), 
      index = "shannon"
    ), na.rm = TRUE),
    riqueza = n_distinct(Especie),
    abundancia = n(),
    .groups = "drop"
  )

cat("\nüìä RESUMO POR TRANSECTO:\n")
print(summary(riqueza_transecto))

cat("\nüìà Estat√≠sticas descritivas:\n")
cat("  - Riqueza m√©dia:", round(mean(riqueza_transecto$riqueza), 2), "¬±", 
    round(sd(riqueza_transecto$riqueza), 2), "\n")
cat("  - Abund√¢ncia m√©dia:", round(mean(riqueza_transecto$abundancia), 2), "¬±", 
    round(sd(riqueza_transecto$abundancia), 2), "\n")

cat("\n\n=== GLMM COM TRANSECTOS ===\n")
cat("Local inclu√≠do como efeito aleat√≥rio (3 transectos por local)\n\n")

riqueza_transecto <- riqueza_transecto %>%
  mutate(
    prop_hab_natural_c = scale(prop_hab_natural, center = TRUE, scale = FALSE)[,1],
    heterogeneidade_c = scale(heterogeneidade, center = TRUE, scale = FALSE)[,1]
  )

m1_t <- glmer(riqueza ~ prop_hab_natural_c + (1|Local), 
              data = riqueza_transecto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

m2_t <- glmer(riqueza ~ heterogeneidade_c + (1|Local), 
              data = riqueza_transecto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

m3_t <- glmer(riqueza ~ prop_hab_natural_c + heterogeneidade_c + (1|Local), 
              data = riqueza_transecto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

m4_t <- glmer(riqueza ~ prop_hab_natural_c * heterogeneidade_c + (1|Local), 
              data = riqueza_transecto, 
              family = poisson,
              control = glmerControl(optimizer = "bobyqa"))

tabela_modelos_transecto <- model.sel(m1_t, m2_t, m3_t, m4_t)
cat("Sele√ß√£o de modelos (transectos):\n")
print(tabela_modelos_transecto)

melhor_modelo_transecto <- get.models(tabela_modelos_transecto, subset = 1)[[1]]

cat("\nüìä MELHOR MODELO (Transectos):\n")
cat("AICc:", round(AICc(melhor_modelo_transecto), 2), "\n\n")
cat("Coeficientes:\n")
print(summary(melhor_modelo_transecto)$coefficients)

if(length(fixef(melhor_modelo_transecto)) > 2) {
  cat("\nüîç VIF (Transectos):\n")
  print(vif(melhor_modelo_transecto))
}

cat("\n\n=== PREPARANDO MATRIZES (TRANSECTOS) ===\n")

matriz_transecto <- dados_transecto %>%
  group_by(ID_transecto, Especie) %>%
  summarise(abundancia = n(), .groups = "drop") %>%
  pivot_wider(names_from = Especie, 
              values_from = abundancia, 
              values_fill = 0) %>%
  column_to_rownames("ID_transecto")

cat("üìê Dimens√µes da matriz:", dim(matriz_transecto), "\n")
cat("   (", nrow(matriz_transecto), " transectos √ó ", 
    ncol(matriz_transecto), " esp√©cies)\n\n", sep = "")

vars_transecto <- riqueza_transecto %>%
  column_to_rownames("ID_transecto")

cat("‚úì Alinhamento de matrizes:", 
    all(rownames(matriz_transecto) == rownames(vars_transecto)), "\n")

cat("\n=== NMDS (TRANSECTOS) ===\n")

set.seed(123)
nmds_transecto <- metaMDS(matriz_transecto, 
                          distance = "bray", 
                          k = 2,
                          trymax = 100,
                          trace = FALSE)

cat("üìä Stress (k=2):", round(nmds_transecto$stress, 4), "\n")

if(nmds_transecto$stress > 0.20) {
  cat("‚ö†Ô∏è Stress alto! Tentando k=3...\n")
  nmds_transecto <- metaMDS(matriz_transecto, 
                            distance = "bray", 
                            k = 3,
                            trymax = 100,
                            trace = FALSE)
  cat("‚úì Novo stress (k=3):", round(nmds_transecto$stress, 4), "\n")
}

cat("\n\n=== ANOSIM (TRANSECTOS) ===\n\n")

dist_transecto <- vegdist(matriz_transecto, method = "bray")

anosim_contexto_t <- anosim(dist_transecto, 
                            vars_transecto$contexto, 
                            permutations = 999)

anosim_local_t <- anosim(dist_transecto, 
                         vars_transecto$Local, 
                         permutations = 999)

anosim_blocked_t <- anosim(dist_transecto, 
                           vars_transecto$contexto, 
                           permutations = 999,
                           strata = vars_transecto$Local)

cat("--- ANOSIM: Contexto (Transectos) ---\n")
print(summary(anosim_contexto_t))

cat("\n--- ANOSIM: Entre Locais (Transectos) ---\n")
print(summary(anosim_local_t))

cat("\n--- ANOSIM BLOQUEADO: Contexto (Transectos) ---\n")
print(summary(anosim_blocked_t))

cat("\n=== ENVFIT (TRANSECTOS) ===\n")

envfit_transecto <- envfit(nmds_transecto, 
                           vars_transecto[, c("prop_hab_natural", "heterogeneidade")],
                           permutations = 999)
print(envfit_transecto)

cat("\n\n")
cat("==============================================================\n")
cat("         COMPARA√á√ÉO: PONTOS (n=54) vs TRANSECTOS (n=18)      \n")
cat("==============================================================\n\n")

comparacao <- data.frame(
  Analise = c(
    "ANOSIM - Contexto",
    "ANOSIM - Entre Locais",
    "ANOSIM Bloqueado",
    "ENVFIT - Habitat Natural (r¬≤)",
    "ENVFIT - Heterogeneidade (r¬≤)"
  ),
  Pontos_R = c(
    round(anosim_contexto$statistic, 3),
    round(anosim_local$statistic, 3),
    round(anosim_blocked_contexto$statistic, 3),
    round(envfit_resultado$vectors$r[1], 3),
    round(envfit_resultado$vectors$r[2], 3)
  ),
  Pontos_p = c(
    round(anosim_contexto$signif, 3),
    round(anosim_local$signif, 3),
    round(anosim_blocked_contexto$signif, 3),
    round(envfit_resultado$vectors$pvals[1], 3),
    round(envfit_resultado$vectors$pvals[2], 3)
  ),
  Transectos_R = c(
    round(anosim_contexto_t$statistic, 3),
    round(anosim_local_t$statistic, 3),
    round(anosim_blocked_t$statistic, 3),
    round(envfit_transecto$vectors$r[1], 3),
    round(envfit_transecto$vectors$r[2], 3)
  ),
  Transectos_p = c(
    round(anosim_contexto_t$signif, 3),
    round(anosim_local_t$signif, 3),
    round(anosim_blocked_t$signif, 3),
    round(envfit_transecto$vectors$pvals[1], 3),
    round(envfit_transecto$vectors$pvals[2], 3)
  )
)

print(comparacao)

cat("\nüí° INTERPRETA√á√ÉO:\n")
cat("Se os resultados forem consistentes entre escalas ‚Üí padr√£o robusto!\n")
cat("Se diferirem ‚Üí discutir depend√™ncia de escala\n")
```

---

# Visualiza√ß√µes

## Preparar Dados para Gr√°ficos
```{r preparar-graficos}
nmds_scores <- as.data.frame(scores(nmds_pontos, display = "sites"))
nmds_scores$ID_ponto <- rownames(nmds_scores)
nmds_scores <- nmds_scores %>%
  left_join(variaveis_pontos %>% rownames_to_column("ID_ponto"), by = "ID_ponto")
```

## NMDS por Contexto
```{r fig-nmds-contexto, fig.cap="Figura 1: Composi√ß√£o de abelhas em bordas urbanas vs zonas rurais", fig.width=10, fig.height=8}
hull_contexto <- nmds_scores %>%
  group_by(contexto) %>%
  slice(chull(NMDS1, NMDS2))

ggplot() +
  geom_polygon(data = hull_contexto, 
               aes(x = NMDS1, y = NMDS2, fill = contexto, group = contexto),
               alpha = 0.3) +
  geom_point(data = nmds_scores, 
             aes(x = NMDS1, y = NMDS2, color = contexto, shape = contexto),
             size = 4, alpha = 0.8) +
  scale_fill_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60")) +
  scale_color_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60")) +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_text(face = "bold"),
    panel.grid = element_blank()
  ) +
  labs(
    x = "NMDS1", y = "NMDS2",
    title = paste0("Composi√ß√£o de abelhas: Borda Urbana vs Zona Rural\n(Stress = ", 
                   round(nmds_pontos$stress, 3), ")"),
    subtitle = paste0("ANOSIM R = ", round(anosim_contexto$statistic, 3), 
                      ", p = ", anosim_contexto$signif),
    color = "Contexto", fill = "Contexto", shape = "Contexto"
  )
```

## NMDS por Local
```{r fig-nmds-local, fig.cap="Figura 2: Composi√ß√£o de abelhas por local de amostragem", fig.width=11, fig.height=8}
hull_local <- nmds_scores %>%
  group_by(Local) %>%
  slice(chull(NMDS1, NMDS2))

ggplot() +
  geom_polygon(data = hull_local, 
               aes(x = NMDS1, y = NMDS2, fill = Local, group = Local),
               alpha = 0.3) +
  geom_point(data = nmds_scores, 
             aes(x = NMDS1, y = NMDS2, color = Local),
             size = 3.5, alpha = 0.8) +
  scale_fill_viridis_d(option = "turbo") +
  scale_color_viridis_d(option = "turbo") +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(legend.position = "right", panel.grid = element_blank()) +
  labs(
    x = "NMDS1", y = "NMDS2",
    title = paste0("Composi√ß√£o por Local (Stress = ", round(nmds_pontos$stress, 3), ")"),
    subtitle = paste0("ANOSIM R = ", round(anosim_local$statistic, 3), 
                      ", p = ", anosim_local$signif)
  )
```

## Gradiente de Habitat Natural
```{r fig-gradiente, fig.cap="Figura 3: Gradiente de propor√ß√£o de habitat natural", fig.width=10, fig.height=8}
ggplot(nmds_scores, aes(x = NMDS1, y = NMDS2, color = prop_hab_natural)) +
  geom_point(size = 4, alpha = 0.8) +
  scale_color_viridis_c(name = "Propor√ß√£o\nHabitat Natural", option = "plasma") +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(panel.grid = element_blank()) +
  labs(
    x = "NMDS1", y = "NMDS2",
    title = paste0("Gradiente de Habitat Natural (Stress = ", round(nmds_pontos$stress, 3), ")")
  )
```

## Vetores Ambientais (ENVFIT)
```{r fig-envfit, fig.cap="Figura 4: Vetores ambientais correlacionados com a ordena√ß√£o", fig.width=10, fig.height=8}
envfit_coords <- as.data.frame(scores(envfit_resultado, "vectors")) * 0.5

ggplot() +
  geom_point(data = nmds_scores, 
             aes(x = NMDS1, y = NMDS2, color = contexto),
             size = 3, alpha = 0.7) +
  geom_segment(data = envfit_coords,
               aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
               arrow = arrow(length = unit(0.3, "cm")),
               color = "black", size = 1.2) +
  geom_text(data = envfit_coords,
            aes(x = NMDS1 * 1.1, y = NMDS2 * 1.1, label = rownames(envfit_coords)),
            size = 5, fontface = "bold") +
  scale_color_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60")) +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(panel.grid = element_blank()) +
  labs(x = "NMDS1", y = "NMDS2", title = "Vetores Ambientais (ENVFIT)", color = "Contexto")
```

## ANOSIM Pairwise
```{r fig-anosim, fig.width=10, fig.height=12, fig.cap="Figura 5: Compara√ß√µes par-a-par entre locais"}
ggplot(resultados_pairwise, 
       aes(x = reorder(Comparacao, R_statistic), y = R_statistic,
           fill = p_adjusted < 0.05)) +
  geom_col() +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "red", size = 1) +
  scale_fill_manual(
    values = c("TRUE" = "#27AE60", "FALSE" = "gray70"),
    labels = c("p < 0.05", "p ‚â• 0.05"),
    name = "Signific√¢ncia"
  ) +
  coord_flip() +
  theme_bw(base_size = 12) +
  labs(
    x = "Compara√ß√£o entre Locais",
    y = "ANOSIM R statistic",
    title = "Diferencia√ß√£o Par-a-Par entre Locais",
    subtitle = "Linha tracejada: R = 0.5 (diferen√ßa forte)"
  )
```

## Riqueza vs Habitat Natural
```{r fig-riqueza-habitat, fig.cap="Figura 6: Rela√ß√£o entre riqueza e propor√ß√£o de habitat natural", fig.width=10, fig.height=7}
ggplot(riqueza_por_ponto, aes(x = prop_hab_natural, y = riqueza, color = contexto)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_smooth(method = "glm", method.args = list(family = "poisson"), 
              se = TRUE, linewidth = 1.2) +
  scale_color_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60"),
                     name = "Contexto") +
  theme_bw(base_size = 14) +
  theme(
    legend.position = "top",
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Propor√ß√£o de Habitat Natural",
    y = "Riqueza de Esp√©cies",
    title = "Rela√ß√£o entre Habitat Natural e Riqueza de Abelhas",
    subtitle = "Linhas = predi√ß√µes do GLM Poisson por contexto"
  )
```

---

# Tabela Resumo
```{r tabela-resumo}
resumo_analises <- data.frame(
  Analise = c(
    "GLMM - Melhor modelo",
    "ANOSIM - Borda vs Rural",
    "ANOSIM - Entre Locais",
    "ANOSIM - Categoria Habitat",
    "ANOSIM - Categoria Heterog",
    "ANOSIM Bloqueado - Contexto",
    "ENVFIT - Habitat Natural",
    "ENVFIT - Heterogeneidade"
  ),
  Estatistica = c(
    paste0("AICc = ", round(AICc(melhor_modelo), 1)),
    paste0("R = ", round(anosim_contexto$statistic, 3)),
    paste0("R = ", round(anosim_local$statistic, 3)),
    paste0("R = ", round(anosim_habitat$statistic, 3)),
    paste0("R = ", round(anosim_heterog$statistic, 3)),
    paste0("R = ", round(anosim_blocked_contexto$statistic, 3)),
    paste0("r¬≤ = ", round(envfit_resultado$vectors$r[1], 3)),
    paste0("r¬≤ = ", round(envfit_resultado$vectors$r[2], 3))
  ),
  p_value = c(
    ifelse(length(fixef(melhor_modelo)) > 2, 
           round(summary(melhor_modelo)$coefficients[2, 4], 4), 
           "‚Äî"),
    round(anosim_contexto$signif, 4),
    round(anosim_local$signif, 4),
    round(anosim_habitat$signif, 4),
    round(anosim_heterog$signif, 4),
    round(anosim_blocked_contexto$signif, 4),
    round(envfit_resultado$vectors$pvals[1], 4),
    round(envfit_resultado$vectors$pvals[2], 4)
  )
)

resumo_analises
```

---

# Conclus√µes

## Principais Resultados

Este documento apresentou uma an√°lise completa das comunidades de abelhas do Cerrado usando **ANOSIM** como m√©todo principal para testar diferen√ßas na composi√ß√£o, incluindo:

### 1. Diversidade Alfa (GLMM)

- Utilizamos **modelos mistos** (GLMM) com os **54 pontos**, controlando a pseudorreplica√ß√£o atrav√©s do efeito aleat√≥rio de Local
- **Vari√°veis centradas** foram utilizadas para reduzir problemas de multicolinearidade na intera√ß√£o
- Esta abordagem √© **estatisticamente mais robusta** do que usar apenas os 6 locais como unidades independentes
- O melhor modelo (menor AICc) foi selecionado atrav√©s de compara√ß√£o entre modelos candidatos

### 2. Composi√ß√£o Beta (ANOSIM)

- **NMDS** revelou padr√µes claros de separa√ß√£o entre contextos (stress = `r round(nmds_pontos$stress, 3)`)
- **ANOSIM** confirmou diferen√ßas significativas entre bordas urbanas e zonas rurais (R = `r round(anosim_contexto$statistic, 3)`, p = `r anosim_contexto$signif`)
- **ANOSIM bloqueado** controlou a pseudorreplica√ß√£o atrav√©s de permuta√ß√µes restritas dentro dos locais
- An√°lises pairwise identificaram quais pares de locais diferem significativamente
- Categoriza√ß√£o de habitat natural e heterogeneidade permitiu testar efeitos de gradientes cont√≠nuos

### 3. An√°lise em M√∫ltiplas Escalas

- **An√°lises com transectos (n=18)** complementaram as an√°lises com pontos (n=54)
- Compara√ß√£o entre escalas permitiu avaliar a robustez dos padr√µes encontrados
- Resultados consistentes entre escalas indicam padr√µes generaliz√°veis

## Vantagens do ANOSIM

‚úÖ **Robusto a diferen√ßas de dispers√£o**: Menos sens√≠vel a heterogeneidade de vari√¢ncias entre grupos  
‚úÖ **Interpreta√ß√£o intuitiva**: R statistic f√°cil de interpretar (0 = sem diferen√ßa, 1 = completamente distinto)  
‚úÖ **Permuta√ß√µes bloqueadas**: Controla pseudorreplica√ß√£o (equivalente √† PERMANOVA bloqueada)  
‚úÖ **Compara√ß√µes m√∫ltiplas**: An√°lises pairwise identificam quais grupos diferem

## Destaques Metodol√≥gicos

‚úÖ **Controle de Pseudorreplica√ß√£o**: Uso de GLMM, ANOSIM bloqueado, e an√°lises em m√∫ltiplas escalas  
‚úÖ **Corre√ß√£o de Multicolinearidade**: Centraliza√ß√£o de vari√°veis para modelos com intera√ß√£o  
‚úÖ **M√∫ltiplas Escalas**: An√°lises em n√≠vel de ponto (54) e transecto (18)  
‚úÖ **Robustez Estat√≠stica**: Sele√ß√£o de modelos via AICc  
‚úÖ **Visualiza√ß√µes Claras**: Gr√°ficos de alta qualidade para publica√ß√£o

## Nota sobre PERMANOVA vs ANOSIM

Este script usa **ANOSIM** no lugar de PERMANOVA. Ambas as an√°lises testam diferen√ßas na composi√ß√£o de comunidades, mas:

- **PERMANOVA** testa se os centr√≥ides dos grupos diferem (an√°loga a ANOVA)
- **ANOSIM** testa se diferen√ßas entre grupos > diferen√ßas dentro dos grupos (baseada em ranks)

ANOSIM √© mais conservadora e robusta a diferen√ßas de dispers√£o entre grupos, sendo uma escolha adequada para este tipo de an√°lise.

## Arquivos Gerados

Este script gera automaticamente:

- ‚úÖ 6 figuras de alta qualidade (incorporadas neste relat√≥rio)
- ‚úÖ Este relat√≥rio HTML completo e reproduz√≠vel
- ‚úÖ Todas as an√°lises estat√≠sticas necess√°rias
- ‚úÖ Compara√ß√µes entre diferentes escalas de an√°lise

---

# Informa√ß√µes da Sess√£o
```{r sessao}
sessionInfo()
```

---

<div style="text-align: center; margin-top: 50px; padding: 20px; background-color: #f0f0f0; border-radius: 10px;">
**An√°lise realizada em:** `r format(Sys.Date(), '%d/%m/%Y')`

**Vers√£o:** ANOSIM com an√°lise multiescala e corre√ß√£o de multicolinearidade

**Contato:** cinthia.soares@ufvjm.edu.br

---

*Documento gerado com R Markdown*
</div>