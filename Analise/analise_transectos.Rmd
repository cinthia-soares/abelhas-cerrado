---
title: "Composi√ß√£o/diversidade de comunidades de abelhas - An√°lise por Transectos"
subtitle: "Unidade Amostral: Transectos (18 unidades) | 6 Locais √ó 3 Transectos"
author: "Cinthia Soares Novaes"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    theme: flatly
    highlight: tango
    code_folding: show
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 7,
  fig.align = 'center'
)
```

# Introdu√ß√£o {.tabset}

## Contexto

**‚ö†Ô∏è IMPORTANTE:** Esta an√°lise utiliza **TRANSECTOS** como unidade amostral (n=18), n√£o pontos individuais (n=54), para evitar pseudorreplica√ß√£o.

**Estrutura hier√°rquica dos dados:**
```
6 Locais (IF, TM, MARM, SG, MV, CUR)
  ‚îî‚îÄ 3 Transectos por local (URB, TRAN, NAT)
      ‚îî‚îÄ 3 Pontos por transecto (agregados)
```

**Pergunta:** Como a composi√ß√£o e a diversidade de abelhas respondem √† estrutura da paisagem, considerando a propor√ß√£o de habitat natural e a heterogeneidade de usos e coberturas do solo?

**H1:** A diversidade e a composi√ß√£o de abelhas est√£o mais fortemente associadas √† propor√ß√£o de habitat natural, de modo que √°reas com maior cobertura natural apresentam maior diversidade de esp√©cies.

**H2:** Mosaicos de diferentes classes de uso e cobertura do solo oferecem recursos complementares que sustentam maior diversidade e mant√™m comunidades distintas, tornando a heterogeneidade da paisagem um preditor mais importante.

**H0:** N√£o h√° associa√ß√£o significativa entre a propor√ß√£o de habitat natural e a heterogeneidade da paisagem e os padr√µes de diversidade e composi√ß√£o de abelhas neste estudo.

## Delineamento Amostral

- **6 locais** com diferentes contextos
  - **Urbanos:** TM, IF, MARM (bordas urbanas)
  - **Rurais:** CUR, SG, MV (zonas rurais)
- **3 transectos** por local (URB, TRAN, NAT)
- **3 pontos** por transecto (agregados para esta an√°lise)
- **Total: 18 transectos** (unidades amostrais independentes)

## M√©todos Estat√≠sticos

- **GLMM (Modelo Misto)**: Riqueza por transecto (n=18) com Local como efeito aleat√≥rio
- **NMDS**: Ordena√ß√£o da composi√ß√£o de esp√©cies por transecto
- **PERMANOVA**: Teste de efeito de vari√°veis ambientais (bloqueada por Local)
- **ANOSIM**: Diferen√ßas entre grupos (contextos, locais e gradiente URB-TRAN-NAT)
- **IndVal e SIMPER**: Esp√©cies indicadoras e contribuintes

---

# Configura√ß√£o Inicial

## Carregar Pacotes

```{r pacotes}
library(tidyverse)
library(readxl)
library(vegan)
library(lme4)
library(lmerTest)  # Para p-valores em modelos mistos
library(MuMIn)
library(indicspecies)
library(ggplot2)
library(viridis)
library(gridExtra)
library(car)
library(scales)
```

## Importar e Preparar Dados

```{r importar-dados}
# Importar dados
# For√ßando tipos de coluna para evitar erros de leitura
dados <- read_excel("../dados/Cap2.xlsx", 
                    sheet = "Doc_Cinthia",
                    col_types = "text",  # Ler tudo como texto primeiro
                    .name_repair = "minimal")

# Limpeza inicial
dados <- dados %>%
  filter(
    Especie != "Vespa",
    Especie != "NA",
    !is.na(Especie),
    Especie != "Crabronidae sp.",
    Especie != "Xylocopa grisescens"
  ) %>%
  mutate(
    Especie = str_trim(Especie),
    # Converter colunas num√©ricas
    Area_Natural = as.numeric(Area_Natural),
    Area_Urbana = as.numeric(Area_Urbana),
    Pastagem = as.numeric(Pastagem),
    Mosaico_Usos = as.numeric(Mosaico_Usos),
    Areas_nao_veg. = as.numeric(Areas_nao_veg.),
    Mineracao = as.numeric(Mineracao),
    Lagos = as.numeric(Lagos),
    Lavouras_Temp. = as.numeric(Lavouras_Temp.),
    # Calcular total da paisagem
    total_paisagem = Area_Natural + Area_Urbana + Pastagem + Mosaico_Usos +
      Areas_nao_veg. + Mineracao + Lagos + Lavouras_Temp.,
    contexto = case_when(
      Local %in% c("TM_", "IF_", "MARM_") ~ "Borda_Urbana",
      Local %in% c("SG_", "MV_", "CUR_") ~ "Zona_Rural",
      TRUE ~ NA_character_
    )
  )

cat("üìä DADOS BRUTOS:\n")
cat("  - Total de registros:", nrow(dados), "\n")
cat("  - N√∫mero de esp√©cies:", n_distinct(dados$Especie), "\n")
cat("  - Locais:", n_distinct(dados$Local), "\n")
cat("  - Pontos individuais:", n_distinct(dados$Ponto), "\n")
```

## Agregar por Transecto

```{r agregar-transectos}
# Criar identificador de transecto √∫nico
dados <- dados %>%
  mutate(
    # Extrair tipo de transecto do nome do ponto
    tipo_transecto = case_when(
      str_detect(Ponto, "URB") ~ "URB",
      str_detect(Ponto, "TRAN") ~ "TRAN",
      str_detect(Ponto, "NAT") ~ "NAT",
      TRUE ~ NA_character_
    ),
    # ID √∫nico do transecto (ex: "IF_URB", "TM_TRAN")
    ID_transecto = paste0(str_remove(Local, "_$"), "_", tipo_transecto)
  )

# Verificar se todos os pontos foram classificados
cat("\nüîç Verifica√ß√£o da classifica√ß√£o de transectos:\n")
cat("  - Pontos com transecto identificado:", 
    sum(!is.na(dados$tipo_transecto)), "/", nrow(dados), "\n")
cat("  - Transectos √∫nicos:", n_distinct(dados$ID_transecto, na.rm = TRUE), "\n\n")

# Mostrar distribui√ß√£o
cat("Distribui√ß√£o por tipo de transecto:\n")
print(table(dados$tipo_transecto, useNA = "ifany"))

cat("\nTransectos √∫nicos identificados:\n")
print(sort(unique(dados$ID_transecto)))

# Remover registros sem transecto identificado (se houver)
dados <- dados %>% filter(!is.na(tipo_transecto))

cat("\n‚úÖ Dados prontos para agrega√ß√£o por transecto\n")
cat("   Total de registros v√°lidos:", nrow(dados), "\n")
```

---

# Diversidade Alfa (GLMM - 18 transectos)

## Calcular Riqueza e Abund√¢ncia por Transecto

```{r riqueza-transectos}
# Agregar dados por transecto
riqueza_por_transecto <- dados %>%
  group_by(ID_transecto) %>%
  summarise(
    Local = first(str_remove(Local, "_$")),
    contexto = first(contexto),
    tipo_transecto = first(tipo_transecto),
    prop_hab_natural = first(Area_Natural) / first(total_paisagem),
    heterogeneidade = vegan::diversity(
      c(first(Area_Urbana), first(Pastagem), first(Mosaico_Usos),
        first(Areas_nao_veg.), first(Mineracao), first(Lagos), 
        first(Lavouras_Temp.)),
      index = "shannon"
    ),
    riqueza = n_distinct(Especie),
    abundancia = n(),
    .groups = "drop"
  ) %>%
  mutate(
    # Ordenar fator para gradiente urbano ‚Üí natural
    tipo_transecto = factor(tipo_transecto, levels = c("URB", "TRAN", "NAT"))
  )

cat("üìä RESUMO DA RIQUEZA POR TRANSECTO (n=18):\n\n")
print(summary(riqueza_por_transecto))

cat("\nüìà Estat√≠sticas Descritivas:\n")
cat("  - Riqueza m√©dia:", round(mean(riqueza_por_transecto$riqueza), 2), "¬±", 
    round(sd(riqueza_por_transecto$riqueza), 2), "\n")
cat("  - Riqueza m√≠nima:", min(riqueza_por_transecto$riqueza), "\n")
cat("  - Riqueza m√°xima:", max(riqueza_por_transecto$riqueza), "\n")
cat("  - Abund√¢ncia m√©dia:", round(mean(riqueza_por_transecto$abundancia), 2), "¬±", 
    round(sd(riqueza_por_transecto$abundancia), 2), "\n")

# Tabela por contexto
cat("\nüìã Riqueza m√©dia por contexto:\n")
riqueza_por_transecto %>%
  group_by(contexto) %>%
  summarise(
    n_transectos = n(),
    riqueza_media = round(mean(riqueza), 2),
    riqueza_sd = round(sd(riqueza), 2),
    .groups = "drop"
  ) %>%
  print()

# Tabela por tipo de transecto
cat("\nüìã Riqueza m√©dia por tipo de transecto:\n")
riqueza_por_transecto %>%
  group_by(tipo_transecto) %>%
  summarise(
    n_transectos = n(),
    riqueza_media = round(mean(riqueza), 2),
    riqueza_sd = round(sd(riqueza), 2),
    .groups = "drop"
  ) %>%
  print()
```

## Modelos Lineares Generalizados Mistos (GLMM)

### Sele√ß√£o de Modelos

```{r glmm-selecao}
cat("\n=== AJUSTANDO GLMMs (n=18 transectos) ===\n")
cat("Local inclu√≠do como efeito aleat√≥rio (1|Local) para controlar pseudorreplica√ß√£o\n\n")

# Modelos candidatos
m1 <- glmer(riqueza ~ prop_hab_natural + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m2 <- glmer(riqueza ~ heterogeneidade + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m3 <- glmer(riqueza ~ prop_hab_natural + heterogeneidade + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m4 <- glmer(riqueza ~ prop_hab_natural * heterogeneidade + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m5 <- glmer(riqueza ~ tipo_transecto + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m6 <- glmer(riqueza ~ prop_hab_natural + tipo_transecto + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m7 <- glmer(riqueza ~ heterogeneidade + tipo_transecto + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

m8 <- glmer(riqueza ~ (prop_hab_natural + heterogeneidade) * tipo_transecto + (1|Local), 
            data = riqueza_por_transecto, 
            family = poisson,
            control = glmerControl(optimizer = "bobyqa"))

# Comparar modelos
cat("Comparando modelos via AICc...\n\n")
tabela_modelos <- model.sel(m1, m2, m3, m4, m5, m6, m7, m8)
print(tabela_modelos)
```

### Melhor Modelo

```{r glmm-melhor}
# Extrair melhor modelo
melhor_modelo <- get.models(tabela_modelos, subset = 1)[[1]]

cat("\nüìä MELHOR MODELO (menor AICc):\n")
cat("F√≥rmula:", deparse(formula(melhor_modelo)), "\n")
cat("AICc:", round(AICc(melhor_modelo), 2), "\n")
cat("ŒîAICc:", round(tabela_modelos$delta[1], 2), "\n\n")

# Mostrar coeficientes
cat("Efeitos fixos:\n")
print(summary(melhor_modelo)$coefficients)

cat("\n\nVari√¢ncia do efeito aleat√≥rio (Local):\n")
print(VarCorr(melhor_modelo))

# ICC (Intraclass Correlation Coefficient)
var_local <- as.numeric(VarCorr(melhor_modelo)$Local[1])
var_residual <- pi^2/3  # Para Poisson
ICC <- var_local / (var_local + var_residual)
cat("\nICC (Correla√ß√£o Intraclasse):", round(ICC, 3), "\n")
cat("Interpreta√ß√£o: ", round(ICC*100, 1), "% da varia√ß√£o est√° entre locais\n", sep="")

# Testar overdispersion
deviance_residual <- sum(residuals(melhor_modelo, type = "deviance")^2)
df_residual <- df.residual(melhor_modelo)
dispersion <- deviance_residual / df_residual

cat("\nüîç Teste de Overdispersion:", round(dispersion, 3), "\n")
if(dispersion > 1.5) {
  cat("‚ö†Ô∏è Overdispersion detectada (>1.5). Considere usar fam√≠lia Negative Binomial.\n")
} else {
  cat("‚úì Sem problemas de overdispersion.\n")
}

# VIF (verificar colinearidade - s√≥ para modelos com 2+ preditores fixos)
# VIF precisa de pelo menos 2 preditores (al√©m do intercepto)
n_fixef <- length(fixef(melhor_modelo))
if(n_fixef > 2) {  # Mais de 2 = intercepto + pelo menos 2 preditores
  cat("\nüîç VIF (Colinearidade dos preditores):\n")
  cat("VIF > 3 indica colinearidade problem√°tica\n\n")
  
  # Tentar calcular VIF com prote√ß√£o contra erros
  vif_result <- tryCatch({
    vif(melhor_modelo)
  }, error = function(e) {
    cat("‚ö†Ô∏è N√£o foi poss√≠vel calcular VIF (modelo pode ter apenas 1 preditor)\n")
    return(NULL)
  })
  
  if(!is.null(vif_result)) {
    print(vif_result)
    if(any(vif_result > 3)) {
      cat("\n‚ö†Ô∏è Aten√ß√£o: VIF > 3 detectado para algum preditor\n")
    } else {
      cat("\n‚úì Sem problemas de colinearidade (VIF < 3)\n")
    }
  }
} else {
  cat("\n‚úì Modelo com apenas 1 preditor - VIF n√£o necess√°rio\n")
}

# R¬≤ marginal e condicional
r2_values <- MuMIn::r.squaredGLMM(melhor_modelo)
cat("\nüìä R¬≤ do modelo:\n")
cat("  - R¬≤ marginal (efeitos fixos):", round(r2_values[1], 3), "\n")
cat("  - R¬≤ condicional (fixos + aleat√≥rios):", round(r2_values[2], 3), "\n")
```

### Compara√ß√£o com Modelos Competidores

```{r modelos-competidores}
cat("\n=== MODELOS COMPETIDORES (ŒîAICc < 2) ===\n\n")

modelos_competidores <- tabela_modelos %>%
  filter(delta < 2)

if(nrow(modelos_competidores) > 1) {
  cat("N√∫mero de modelos competidores:", nrow(modelos_competidores), "\n\n")
  
  # Selecionar apenas colunas que existem
  colunas_disponiveis <- intersect(c("df", "logLik", "AICc", "delta", "weight"), 
                                   colnames(modelos_competidores))
  print(modelos_competidores[, colunas_disponiveis])
  
  cat("\nüí° Interpreta√ß√£o:\n")
  cat("  - M√∫ltiplos modelos com ŒîAICc < 2 sugerem incerteza sobre o melhor modelo\n")
  cat("  - Considere model averaging ou interpretar todos os modelos competidores\n")
} else {
  cat("‚úì Apenas 1 modelo claramente melhor (ŒîAICc > 2 para todos os outros)\n")
}
```

---

# An√°lises Multivariadas (18 transectos)

## Preparar Matrizes de Comunidade

```{r preparar-matrizes}
# Matriz de comunidade: transectos √ó esp√©cies
matriz_comunidade_transectos <- dados %>%
  group_by(ID_transecto, Especie) %>%
  summarise(abundancia = n(), .groups = "drop") %>%
  pivot_wider(names_from = Especie, values_from = abundancia, values_fill = 0) %>%
  column_to_rownames("ID_transecto")

cat("üìê Dimens√µes da matriz de comunidade:\n")
cat("   ", nrow(matriz_comunidade_transectos), " transectos √ó ", 
    ncol(matriz_comunidade_transectos), " esp√©cies\n\n", sep = "")

# Verificar esp√©cies raras
singletons <- colSums(matriz_comunidade_transectos > 0)
cat("Distribui√ß√£o de frequ√™ncia das esp√©cies:\n")
cat("  - Singletons (em apenas 1 transecto):", sum(singletons == 1), "\n")
cat("  - Em 2-3 transectos:", sum(singletons >= 2 & singletons <= 3), "\n")
cat("  - Em 4+ transectos:", sum(singletons >= 4), "\n\n")

# Vari√°veis ambientais por transecto
variaveis_transectos <- riqueza_por_transecto %>%
  select(ID_transecto, Local, contexto, tipo_transecto, 
         prop_hab_natural, heterogeneidade) %>%
  column_to_rownames("ID_transecto")

# Verificar alinhamento
cat("‚úì Alinhamento de matrizes:", 
    all(rownames(matriz_comunidade_transectos) == rownames(variaveis_transectos)), "\n")
```

## NMDS (Ordena√ß√£o)

```{r nmds}
cat("\n=== CALCULANDO NMDS ===\n")

set.seed(123)
nmds_transectos <- metaMDS(matriz_comunidade_transectos, 
                           distance = "bray", 
                           k = 2,
                           trymax = 100,
                           trace = FALSE)

cat("üìä Stress do NMDS (k=2):", round(nmds_transectos$stress, 4), "\n\n")
cat("Interpreta√ß√£o do Stress:\n")
cat("  < 0.05: Excelente\n")
cat("  0.05-0.10: √ìtimo\n")
cat("  0.10-0.20: Bom\n")
cat("  > 0.20: Regular/Ruim\n\n")

# Teste de adequa√ß√£o (Shepard plot)
stressplot(nmds_transectos, main = "Shepard plot - Adequa√ß√£o do NMDS")

# Se stress alto, tentar k=3
if(nmds_transectos$stress > 0.20) {
  cat("\n‚ö†Ô∏è Stress alto! Tentando k=3...\n")
  nmds_transectos_3d <- metaMDS(matriz_comunidade_transectos, 
                                distance = "bray", 
                                k = 3,
                                trymax = 100,
                                trace = FALSE)
  cat("‚úì Novo stress (k=3):", round(nmds_transectos_3d$stress, 4), "\n")
  
  if(nmds_transectos_3d$stress < nmds_transectos$stress) {
    cat("  ‚Üí k=3 tem melhor ajuste. Considere usar esse modelo.\n")
  }
}
```

## PERMANOVA

```{r permanova}
cat("\n\n=== PERMANOVA (n=18 transectos) ===\n")

# Modelo 1: Vari√°veis cont√≠nuas
perm1 <- adonis2(matriz_comunidade_transectos ~ prop_hab_natural + heterogeneidade,
                 data = variaveis_transectos,
                 permutations = 999,
                 method = "bray")

# Modelo 2: + Contexto
perm2 <- adonis2(matriz_comunidade_transectos ~ prop_hab_natural + heterogeneidade + contexto,
                 data = variaveis_transectos,
                 permutations = 999,
                 method = "bray")

# Modelo 3: + Tipo de transecto
perm3 <- adonis2(matriz_comunidade_transectos ~ prop_hab_natural + heterogeneidade + tipo_transecto,
                 data = variaveis_transectos,
                 permutations = 999,
                 method = "bray")

# Modelo 4: Gradiente URB‚ÜíTRAN‚ÜíNAT
perm4 <- adonis2(matriz_comunidade_transectos ~ tipo_transecto,
                 data = variaveis_transectos,
                 permutations = 999,
                 method = "bray")

# Modelo 5: BLOQUEADA por Local (controla pseudorreplica√ß√£o) ‚≠ê
perm_blocked <- adonis2(matriz_comunidade_transectos ~ prop_hab_natural + heterogeneidade,
                        data = variaveis_transectos,
                        permutations = 999,
                        method = "bray",
                        strata = variaveis_transectos$Local)

# Modelo 6: Gradiente bloqueado por Local
perm_gradiente_blocked <- adonis2(matriz_comunidade_transectos ~ tipo_transecto,
                                  data = variaveis_transectos,
                                  permutations = 999,
                                  method = "bray",
                                  strata = variaveis_transectos$Local)

cat("\n--- MODELO 1: Habitat + Heterogeneidade ---\n")
print(perm1)

cat("\n--- MODELO 2: + Contexto ---\n")
print(perm2)

cat("\n--- MODELO 3: + Tipo de Transecto ---\n")
print(perm3)

cat("\n--- MODELO 4: Apenas Gradiente URB‚ÜíTRAN‚ÜíNAT ---\n")
print(perm4)

cat("\n--- MODELO 5: Habitat + Heterog. BLOQUEADO (Local) ‚≠ê ---\n")
print(perm_blocked)

cat("\n--- MODELO 6: Gradiente BLOQUEADO (Local) ‚≠ê ---\n")
print(perm_gradiente_blocked)

cat("\n\nüí° INTERPRETA√á√ÉO:\n")
cat("  - Modelos bloqueados controlam a n√£o-independ√™ncia dos 3 transectos dentro de cada local\n")
cat("  - R¬≤ indica % da varia√ß√£o na composi√ß√£o explicada pelas vari√°veis\n")
cat("  - p < 0.05 indica efeito significativo\n")
```

## ANOSIM

```{r anosim}
cat("\n\n=== ANOSIM ===\n")

# Calcular matriz de dist√¢ncia
dist_bray <- vegdist(matriz_comunidade_transectos, method = "bray")

# 1. Por CONTEXTO
anosim_contexto <- anosim(dist_bray, variaveis_transectos$contexto, permutations = 999)

# 2. Por LOCAL
anosim_local <- anosim(dist_bray, variaveis_transectos$Local, permutations = 999)

# 3. Por TIPO DE TRANSECTO (URB, TRAN, NAT)
anosim_transecto <- anosim(dist_bray, variaveis_transectos$tipo_transecto, permutations = 999)

cat("--- ANOSIM: Borda Urbana vs Zona Rural ---\n")
print(summary(anosim_contexto))

cat("\n--- ANOSIM: Entre os 6 Locais ---\n")
print(summary(anosim_local))

cat("\n--- ANOSIM: Gradiente URB ‚Üí TRAN ‚Üí NAT ---\n")
print(summary(anosim_transecto))

cat("\n\nüí° INTERPRETA√á√ÉO do R statistic:\n")
cat("  R = 0: Grupos indistingu√≠veis\n")
cat("  R < 0.25: Diferen√ßa fraca\n")
cat("  0.25 < R < 0.5: Diferen√ßa moderada\n")
cat("  R > 0.5: Diferen√ßa forte\n")
cat("  R = 1: Grupos completamente distintos\n")
```

### ANOSIM Pairwise (Gradiente)

```{r anosim-pairwise-transecto}
cat("\n--- ANOSIM Pairwise: Gradiente URB vs TRAN vs NAT ---\n\n")

pairwise_gradiente <- data.frame(
  Comparacao = character(),
  R_statistic = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

tipos <- c("URB", "TRAN", "NAT")
for(i in 1:(length(tipos)-1)) {
  for(j in (i+1):length(tipos)) {
    tipo_A <- tipos[i]
    tipo_B <- tipos[j]
    
    indices <- variaveis_transectos$tipo_transecto %in% c(tipo_A, tipo_B)
    dist_sub <- as.dist(as.matrix(dist_bray)[indices, indices])
    grupos_sub <- variaveis_transectos$tipo_transecto[indices]
    
    anosim_pair <- anosim(dist_sub, grupos_sub, permutations = 999)
    
    pairwise_gradiente <- rbind(pairwise_gradiente, 
                                data.frame(
                                  Comparacao = paste(tipo_A, "vs", tipo_B),
                                  R_statistic = anosim_pair$statistic,
                                  p_value = anosim_pair$signif
                                ))
  }
}

pairwise_gradiente$p_adjusted <- p.adjust(pairwise_gradiente$p_value, method = "bonferroni")
print(pairwise_gradiente)

cat("\nüí° Isso mostra se o gradiente urbano ‚Üí transi√ß√£o ‚Üí natural √© linear\n")
```

### ANOSIM Pairwise (Locais)

```{r anosim-pairwise-local}
cat("\n--- ANOSIM Pairwise: Entre os 6 Locais ---\n\n")

locais_unicos <- unique(variaveis_transectos$Local)
n_locais <- length(locais_unicos)

pairwise_locais <- data.frame(
  Comparacao = character(),
  R_statistic = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

for(i in 1:(n_locais-1)) {
  for(j in (i+1):n_locais) {
    local_A <- locais_unicos[i]
    local_B <- locais_unicos[j]
    
    indices <- variaveis_transectos$Local %in% c(local_A, local_B)
    dist_sub <- as.dist(as.matrix(dist_bray)[indices, indices])
    grupos_sub <- variaveis_transectos$Local[indices]
    
    anosim_pair <- anosim(dist_sub, grupos_sub, permutations = 999)
    
    pairwise_locais <- rbind(pairwise_locais, 
                             data.frame(
                               Comparacao = paste(local_A, "vs", local_B),
                               R_statistic = anosim_pair$statistic,
                               p_value = anosim_pair$signif
                             ))
  }
}

pairwise_locais$p_adjusted <- p.adjust(pairwise_locais$p_value, method = "bonferroni")
pairwise_locais <- pairwise_locais %>% arrange(desc(R_statistic))
print(pairwise_locais)
```

## ENVFIT (Vetores Ambientais)

```{r envfit}
cat("\n\n=== ENVFIT: Vetores Ambientais ===\n")

envfit_resultado <- envfit(nmds_transectos, 
                           variaveis_transectos[, c("prop_hab_natural", "heterogeneidade")],
                           permutations = 999)
print(envfit_resultado)

cat("\nüí° ENVFIT mostra a correla√ß√£o das vari√°veis ambientais com a ordena√ß√£o\n")
cat("   r¬≤ = for√ßa da correla√ß√£o | p = signific√¢ncia estat√≠stica\n")
```

## Esp√©cies Indicadoras

```{r especies-indicadoras}
cat("\n\n=== ESP√âCIES INDICADORAS ===\n")

# IndVal por contexto
indval_contexto <- multipatt(matriz_comunidade_transectos, 
                             variaveis_transectos$contexto,
                             control = how(nperm = 999))

cat("--- IndVal: Borda Urbana vs Zona Rural ---\n")
cat("(Mostrando apenas esp√©cies significativas)\n\n")
summary_indval <- summary(indval_contexto, indvalcomp = TRUE)
print(summary_indval)

# IndVal por tipo de transecto (gradiente)
indval_transecto <- multipatt(matriz_comunidade_transectos, 
                              variaveis_transectos$tipo_transecto,
                              control = how(nperm = 999))

cat("\n--- IndVal: Gradiente URB ‚Üí TRAN ‚Üí NAT ---\n")
cat("(Mostrando apenas esp√©cies significativas)\n\n")
summary_transecto <- summary(indval_transecto, indvalcomp = TRUE)
print(summary_transecto)

# SIMPER
simper_contexto <- simper(matriz_comunidade_transectos, variaveis_transectos$contexto)
cat("\n--- SIMPER: Top 10 esp√©cies que diferenciam Borda Urbana vs Zona Rural ---\n\n")
simper_summary <- summary(simper_contexto, ordered = TRUE)
if(length(simper_summary) > 0) {
  print(simper_summary[[1]][1:min(10, nrow(simper_summary[[1]])), ])
}

simper_transecto <- simper(matriz_comunidade_transectos, variaveis_transectos$tipo_transecto)
cat("\n--- SIMPER: Top esp√©cies por gradiente URB-TRAN-NAT ---\n")
cat("(Mostrando compara√ß√£o URB vs NAT)\n\n")
simper_trans_summary <- summary(simper_transecto, ordered = TRUE)
# Mostrar URB vs NAT se existir
comparacoes <- names(simper_trans_summary)
urb_nat <- grep("URB_NAT|NAT_URB", comparacoes, value = TRUE)
if(length(urb_nat) > 0) {
  print(simper_trans_summary[[urb_nat[1]]][1:min(10, nrow(simper_trans_summary[[urb_nat[1]]])), ])
}
```

---

# Visualiza√ß√µes

## Preparar Dados para Gr√°ficos

```{r preparar-graficos}
nmds_scores <- as.data.frame(scores(nmds_transectos, display = "sites"))
nmds_scores$ID_transecto <- rownames(nmds_scores)
nmds_scores <- nmds_scores %>%
  left_join(variaveis_transectos %>% rownames_to_column("ID_transecto"), 
            by = "ID_transecto")
```

## Figura 1: NMDS por Contexto

```{r fig-nmds-contexto, fig.cap="Figura 1: Composi√ß√£o de abelhas - Borda Urbana vs Zona Rural (n=18 transectos)", fig.width=10, fig.height=8}
hull_contexto <- nmds_scores %>%
  group_by(contexto) %>%
  slice(chull(NMDS1, NMDS2))

ggplot() +
  geom_polygon(data = hull_contexto, 
               aes(x = NMDS1, y = NMDS2, fill = contexto, group = contexto),
               alpha = 0.3) +
  geom_point(data = nmds_scores, 
             aes(x = NMDS1, y = NMDS2, color = contexto, shape = contexto),
             size = 5, alpha = 0.8) +
  geom_text(data = nmds_scores,
            aes(x = NMDS1, y = NMDS2, label = tipo_transecto),
            size = 3, fontface = "bold", color = "black",
            nudge_y = 0.03) +
  scale_fill_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60"),
                    name = "Contexto") +
  scale_color_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60"),
                     name = "Contexto") +
  scale_shape_manual(values = c(16, 17), name = "Contexto") +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_text(face = "bold"),
    panel.grid = element_blank()
  ) +
  labs(
    x = "NMDS1", y = "NMDS2",
    title = paste0("Composi√ß√£o de abelhas: Borda Urbana vs Zona Rural\n(Stress = ", 
                   round(nmds_transectos$stress, 3), ")"),
    subtitle = paste0("ANOSIM R = ", round(anosim_contexto$statistic, 3), 
                      ", p = ", anosim_contexto$signif,
                      " | n = 18 transectos"),
    caption = "R√≥tulos indicam tipo de transecto (URB/TRAN/NAT)"
  )
```

## Figura 2: NMDS por Tipo de Transecto

```{r fig-nmds-gradiente, fig.cap="Figura 2: Gradiente urbano-natural (URB ‚Üí TRAN ‚Üí NAT)", fig.width=11, fig.height=8}
hull_transecto <- nmds_scores %>%
  group_by(tipo_transecto) %>%
  slice(chull(NMDS1, NMDS2))

cores_gradiente <- c("URB" = "#E74C3C", "TRAN" = "#F39C12", "NAT" = "#27AE60")

ggplot() +
  geom_polygon(data = hull_transecto, 
               aes(x = NMDS1, y = NMDS2, fill = tipo_transecto, group = tipo_transecto),
               alpha = 0.3) +
  geom_point(data = nmds_scores, 
             aes(x = NMDS1, y = NMDS2, color = tipo_transecto, shape = tipo_transecto),
             size = 5, alpha = 0.8) +
  scale_fill_manual(values = cores_gradiente, name = "Tipo de Transecto") +
  scale_color_manual(values = cores_gradiente, name = "Tipo de Transecto") +
  scale_shape_manual(values = c(15, 16, 17), name = "Tipo de Transecto") +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(
    legend.position = "top",
    panel.grid = element_blank()
  ) +
  labs(
    x = "NMDS1", y = "NMDS2",
    title = paste0("Gradiente Urbano ‚Üí Natural (Stress = ", round(nmds_transectos$stress, 3), ")"),
    subtitle = paste0("ANOSIM R = ", round(anosim_transecto$statistic, 3), 
                      ", p = ", anosim_transecto$signif,
                      " | n = 18 transectos")
  )
```

## Figura 3: NMDS por Local

```{r fig-nmds-local, fig.cap="Figura 3: Composi√ß√£o por local de amostragem", fig.width=11, fig.height=8}
hull_local <- nmds_scores %>%
  group_by(Local) %>%
  slice(chull(NMDS1, NMDS2))

ggplot() +
  geom_polygon(data = hull_local, 
               aes(x = NMDS1, y = NMDS2, fill = Local, group = Local),
               alpha = 0.25) +
  geom_point(data = nmds_scores, 
             aes(x = NMDS1, y = NMDS2, color = Local, shape = tipo_transecto),
             size = 4, alpha = 0.8) +
  scale_fill_viridis_d(option = "turbo") +
  scale_color_viridis_d(option = "turbo") +
  scale_shape_manual(values = c(15, 16, 17), 
                     name = "Tipo", 
                     labels = c("Urbano", "Transi√ß√£o", "Natural")) +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(legend.position = "right", panel.grid = element_blank()) +
  labs(
    x = "NMDS1", y = "NMDS2",
    title = paste0("Composi√ß√£o por Local (Stress = ", round(nmds_transectos$stress, 3), ")"),
    subtitle = paste0("ANOSIM R = ", round(anosim_local$statistic, 3), 
                      ", p = ", anosim_local$signif,
                      " | 6 locais √ó 3 transectos")
  )
```

## Figura 4: Gradiente de Habitat Natural

```{r fig-gradiente, fig.cap="Figura 4: Gradiente de propor√ß√£o de habitat natural", fig.width=10, fig.height=8}
ggplot(nmds_scores, aes(x = NMDS1, y = NMDS2, color = prop_hab_natural, 
                        shape = tipo_transecto)) +
  geom_point(size = 5, alpha = 0.8) +
  scale_color_viridis_c(name = "Propor√ß√£o\nHabitat Natural", 
                        option = "plasma",
                        labels = scales::percent_format()) +
  scale_shape_manual(values = c(15, 16, 17), name = "Tipo de\nTransecto") +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(panel.grid = element_blank()) +
  labs(
    x = "NMDS1", y = "NMDS2",
    title = paste0("Gradiente de Habitat Natural (Stress = ", 
                   round(nmds_transectos$stress, 3), ")"),
    subtitle = "n = 18 transectos"
  )
```

## Figura 5: Vetores Ambientais (ENVFIT)

```{r fig-envfit, fig.cap="Figura 5: Vetores ambientais correlacionados com a ordena√ß√£o", fig.width=10, fig.height=8}
envfit_coords <- as.data.frame(scores(envfit_resultado, "vectors")) * 0.6

ggplot() +
  geom_point(data = nmds_scores, 
             aes(x = NMDS1, y = NMDS2, color = contexto, shape = tipo_transecto),
             size = 4, alpha = 0.7) +
  geom_segment(data = envfit_coords,
               aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
               arrow = arrow(length = unit(0.3, "cm")),
               color = "black", size = 1.2) +
  geom_text(data = envfit_coords,
            aes(x = NMDS1 * 1.15, y = NMDS2 * 1.15, label = rownames(envfit_coords)),
            size = 5, fontface = "bold") +
  scale_color_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60"),
                     name = "Contexto") +
  scale_shape_manual(values = c(15, 16, 17), name = "Tipo de\nTransecto") +
  coord_equal() +
  theme_bw(base_size = 14) +
  theme(panel.grid = element_blank()) +
  labs(
    x = "NMDS1", 
    y = "NMDS2", 
    title = "Vetores Ambientais (ENVFIT)",
    subtitle = paste0("prop_hab_natural: r¬≤=", round(envfit_resultado$vectors$r[1], 3), 
                      ", p=", round(envfit_resultado$vectors$pvals[1], 3), 
                      " | heterogeneidade: r¬≤=", round(envfit_resultado$vectors$r[2], 3),
                      ", p=", round(envfit_resultado$vectors$pvals[2], 3))
  )
```

## Figura 6: ANOSIM Pairwise (Locais)

```{r fig-anosim-locais, fig.width=10, fig.height=12, fig.cap="Figura 6: Diferencia√ß√£o entre locais (ANOSIM pairwise)"}
ggplot(pairwise_locais, 
       aes(x = reorder(Comparacao, R_statistic), y = R_statistic,
           fill = p_adjusted < 0.05)) +
  geom_col() +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "red", size = 1) +
  geom_hline(yintercept = 0.25, linetype = "dotted", color = "orange", size = 0.8) +
  scale_fill_manual(
    values = c("TRUE" = "#27AE60", "FALSE" = "gray70"),
    labels = c("Significativo", "N√£o significativo"),
    name = "p-valor ajustado"
  ) +
  coord_flip() +
  theme_bw(base_size = 12) +
  labs(
    x = "Compara√ß√£o entre Locais",
    y = "ANOSIM R statistic",
    title = "Diferencia√ß√£o Par-a-Par entre Locais",
    subtitle = "Linha tracejada: R=0.5 (forte) | Linha pontilhada: R=0.25 (moderado)",
    caption = "p-valores ajustados por Bonferroni"
  )
```

## Figura 7: Riqueza vs Habitat Natural

```{r fig-riqueza-habitat, fig.cap="Figura 7: Rela√ß√£o entre riqueza e habitat natural por tipo de transecto", fig.width=11, fig.height=8}
ggplot(riqueza_por_transecto, 
       aes(x = prop_hab_natural, y = riqueza, color = tipo_transecto, shape = tipo_transecto)) +
  geom_point(size = 4, alpha = 0.7) +
  geom_smooth(method = "glm", method.args = list(family = "poisson"), 
              se = TRUE, linewidth = 1.2, alpha = 0.2) +
  scale_color_manual(values = cores_gradiente, name = "Tipo de Transecto") +
  scale_shape_manual(values = c(15, 16, 17), name = "Tipo de Transecto") +
  scale_x_continuous(labels = scales::percent_format()) +
  theme_bw(base_size = 14) +
  theme(
    legend.position = "top",
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Propor√ß√£o de Habitat Natural",
    y = "Riqueza de Esp√©cies",
    title = "Rela√ß√£o entre Habitat Natural e Riqueza de Abelhas",
    subtitle = "Linhas = predi√ß√µes do GLM Poisson por tipo de transecto | n = 18 transectos"
  )
```

## Figura 8: Riqueza por Contexto e Tipo de Transecto

```{r fig-boxplot-riqueza, fig.cap="Figura 8: Distribui√ß√£o da riqueza por contexto e tipo de transecto", fig.width=11, fig.height=8}
ggplot(riqueza_por_transecto, 
       aes(x = tipo_transecto, y = riqueza, fill = contexto)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.6, size = 3) +
  scale_fill_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60"),
                    name = "Contexto") +
  theme_bw(base_size = 14) +
  theme(
    legend.position = "top",
    panel.grid.major.x = element_blank()
  ) +
  labs(
    x = "Tipo de Transecto",
    y = "Riqueza de Esp√©cies",
    title = "Distribui√ß√£o da Riqueza ao longo do Gradiente Urbano-Natural",
    subtitle = "n = 18 transectos (9 urbanos + 9 rurais)"
  )
```

## Figura 9: Heterogeneidade vs Riqueza

```{r fig-riqueza-hetero, fig.cap="Figura 9: Rela√ß√£o entre heterogeneidade da paisagem e riqueza", fig.width=10, fig.height=8}
ggplot(riqueza_por_transecto, 
       aes(x = heterogeneidade, y = riqueza, color = contexto, shape = tipo_transecto)) +
  geom_point(size = 4, alpha = 0.7) +
  geom_smooth(method = "glm", method.args = list(family = "poisson"),
              aes(group = contexto), se = TRUE, linewidth = 1.2, alpha = 0.2) +
  scale_color_manual(values = c("Borda_Urbana" = "#E74C3C", "Zona_Rural" = "#27AE60"),
                     name = "Contexto") +
  scale_shape_manual(values = c(15, 16, 17), name = "Tipo de\nTransecto") +
  theme_bw(base_size = 14) +
  theme(
    legend.position = "top",
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Heterogeneidade da Paisagem (√çndice de Shannon)",
    y = "Riqueza de Esp√©cies",
    title = "Rela√ß√£o entre Heterogeneidade e Riqueza de Abelhas",
    subtitle = "n = 18 transectos"
  )
```

---

# Tabela Resumo

```{r tabela-resumo}
resumo_analises <- data.frame(
  Analise = c(
    "GLMM - Melhor modelo",
    "PERMANOVA - Habitat + Heterog",
    "PERMANOVA - + Tipo Transecto",
    "PERMANOVA - Gradiente URB-TRAN-NAT",
    "PERMANOVA - Habitat BLOQUEADA",
    "PERMANOVA - Gradiente BLOQUEADA",
    "ANOSIM - Borda vs Rural",
    "ANOSIM - Entre Locais",
    "ANOSIM - Gradiente URB-TRAN-NAT",
    "ENVFIT - Habitat Natural",
    "ENVFIT - Heterogeneidade"
  ),
  Estatistica = c(
    paste0("AICc = ", round(AICc(melhor_modelo), 1)),
    paste0("R¬≤ = ", round(perm1$R2[1], 3)),
    paste0("R¬≤ = ", round(perm3$R2[1], 3)),
    paste0("R¬≤ = ", round(perm4$R2[1], 3)),
    paste0("R¬≤ = ", round(perm_blocked$R2[1], 3)),
    paste0("R¬≤ = ", round(perm_gradiente_blocked$R2[1], 3)),
    paste0("R = ", round(anosim_contexto$statistic, 3)),
    paste0("R = ", round(anosim_local$statistic, 3)),
    paste0("R = ", round(anosim_transecto$statistic, 3)),
    paste0("r¬≤ = ", round(envfit_resultado$vectors$r[1], 3)),
    paste0("r¬≤ = ", round(envfit_resultado$vectors$r[2], 3))
  ),
  p_value = c(
    "‚Äî",
    round(perm1$`Pr(>F)`[1], 4),
    round(perm3$`Pr(>F)`[1], 4),
    round(perm4$`Pr(>F)`[1], 4),
    round(perm_blocked$`Pr(>F)`[1], 4),
    round(perm_gradiente_blocked$`Pr(>F)`[1], 4),
    round(anosim_contexto$signif, 4),
    round(anosim_local$signif, 4),
    round(anosim_transecto$signif, 4),
    round(envfit_resultado$vectors$pvals[1], 4),
    round(envfit_resultado$vectors$pvals[2], 4)
  ),
  stringsAsFactors = FALSE
)

knitr::kable(resumo_analises, 
             caption = "Tabela 1: Resumo das an√°lises estat√≠sticas (n=18 transectos)",
             align = c("l", "c", "c"))
```

---

# Conclus√µes

## Principais Resultados

### ‚úÖ Vantagens da An√°lise por Transectos (n=18)

1. **Evita pseudorreplica√ß√£o**: Os 3 pontos dentro de cada transecto s√£o tratados como uma √∫nica unidade amostral
2. **Estatisticamente mais correto**: Respeita a estrutura hier√°rquica dos dados
3. **Biologicamente interpret√°vel**: Transectos representam gradientes reais (URB ‚Üí TRAN ‚Üí NAT)
4. **Controle adequado**: Efeito aleat√≥rio (1|Local) controla varia√ß√£o entre os 6 locais

### üìä Resumo das An√°lises

#### 1. Diversidade Alfa (GLMM)
- **n = 18 transectos** (n√£o 54 pontos)
- Melhor modelo selecionado via AICc
- Efeito aleat√≥rio de Local controla n√£o-independ√™ncia
- R¬≤ marginal = efeito apenas das vari√°veis ambientais
- R¬≤ condicional = vari√°veis + estrutura hier√°rquica

#### 2. Composi√ß√£o Beta
- **NMDS** (stress = `r round(nmds_transectos$stress, 3)`): Qualidade da ordena√ß√£o
- **PERMANOVA bloqueada**: Controla pseudorreplica√ß√£o dos 3 transectos por local
- **ANOSIM**:
  - Contexto (Urbano vs Rural): R = `r round(anosim_contexto$statistic, 3)`
  - Gradiente (URB-TRAN-NAT): R = `r round(anosim_transecto$statistic, 3)`
  - Entre locais: R = `r round(anosim_local$statistic, 3)`

#### 3. Esp√©cies Indicadoras
- **IndVal**: Esp√©cies caracter√≠sticas de cada contexto/gradiente
- **SIMPER**: Esp√©cies que mais contribuem para diferen√ßas entre grupos

### üî¨ Interpreta√ß√£o Biol√≥gica

**Gradiente URB ‚Üí TRAN ‚Üí NAT:** 
- Representa um gradiente real de urbaniza√ß√£o
- ANOSIM pairwise mostra se as diferen√ßas s√£o graduais ou abruptas
- Importante para entender zonas de transi√ß√£o

**Contexto (Urbano vs Rural):**
- Diferen√ßas em escala de paisagem
- Relevante para conserva√ß√£o e manejo

### üìà Figuras Geradas

1. ‚úÖ NMDS por contexto (Urbano vs Rural)
2. ‚úÖ NMDS por gradiente (URB-TRAN-NAT)
3. ‚úÖ NMDS por local (6 locais √ó 3 transectos)
4. ‚úÖ Gradiente de habitat natural
5. ‚úÖ Vetores ambientais (ENVFIT)
6. ‚úÖ ANOSIM pairwise entre locais
7. ‚úÖ Riqueza vs habitat natural
8. ‚úÖ Boxplot: Riqueza por contexto e transecto
9. ‚úÖ Riqueza vs heterogeneidade

## Compara√ß√£o: 54 Pontos vs 18 Transectos

| Aspecto | 54 Pontos (‚ùå) | 18 Transectos (‚úÖ) |
|---------|----------------|-------------------|
| **n real** | Inflado | Correto |
| **Pseudorreplica√ß√£o** | Presente | Controlada |
| **Interpreta√ß√£o** | Dif√≠cil | Clara |
| **Poder estat√≠stico** | Falso | Real |
| **Public√°vel** | Question√°vel | Adequado |

## Pr√≥ximos Passos Sugeridos

1. üîç **Verificar pressupostos** dos modelos GLMM
2. üìä **Explorar intera√ß√µes** entre vari√°veis (se biologicamente plaus√≠vel)
3. üêù **Analisar grupos funcionais** (tamanho, sociabilidade, etc.)
4. üìù **Preparar manuscrito** usando esta abordagem estat√≠stica correta

---

# Informa√ß√µes da Sess√£o

```{r sessao}
sessionInfo()
```

---

<div style="text-align: center; margin-top: 50px; padding: 20px; background-color: #f0f0f0; border-radius: 10px;">
**An√°lise realizada em:** `r format(Sys.Date(), '%d/%m/%Y')`

**Unidade amostral:** 18 transectos (6 locais √ó 3 transectos)

**Contato:** cinthia.soares@ufvjm.edu.br

---

*Documento gerado com R Markdown*

**‚ö†Ô∏è IMPORTANTE:** Esta an√°lise usa a estrutura hier√°rquica correta dos dados, evitando pseudorreplica√ß√£o atrav√©s da agrega√ß√£o por transectos e uso de modelos mistos.
</div>
